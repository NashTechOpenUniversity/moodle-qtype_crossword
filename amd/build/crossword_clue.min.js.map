{"version":3,"file":"crossword_clue.min.js","sources":["../src/crossword_clue.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Crossword clue class, handle any action relative to clue.\n *\n * @module qtype_crossword/crossword_clue\n * @copyright 2022 The Open University\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {CrosswordQuestion} from 'qtype_crossword/crossword_question';\n\nexport class CrosswordClue extends CrosswordQuestion {\n\n    /**\n     * Constructor.\n     *\n     * @param {Object} options The settings for crossword.\n     */\n    constructor(options) {\n        super(options);\n    }\n\n    /**\n     * Set up for clue section.\n     */\n    setUpClue() {\n        let {words, readonly} = this.options;\n        const clueEls = this.options.crosswordEl\n            .closest('.qtype_crossword-grid-wrapper')\n            .querySelectorAll('.contain-clue .wrap-clue');\n        clueEls.forEach(el => {\n            const questionId = el.dataset.questionid;\n            let word = words.find(o => o.number === parseInt(questionId));\n            if (word) {\n                const inputEl = el.querySelector('input');\n                inputEl.value += this.makeUnderscore(word.length - inputEl.value.length);\n                if (!readonly) {\n                    inputEl.disabled = false;\n                }\n                // Add event for input.\n                this.addEventForClueInput(inputEl, word);\n            }\n        });\n    }\n\n    /**\n     * Add event to word input element.\n     *\n     * @param {Element} el The input element.\n     * @param {String} word The word data.\n     */\n    addEventForClueInput(el, word) {\n        const {readonly} = this.options;\n        let startSelection = 0;\n        if (readonly) {\n            return;\n        }\n        el.addEventListener('click', (e) => {\n            let startIndex = e.target.selectionStart;\n            if (startIndex >= word.length) {\n                startIndex = word.length - 1;\n            }\n            this.focusCellByStartIndex(startIndex, word);\n            this.focusClue();\n            this.setStickyClue();\n        });\n\n        el.addEventListener('focus', (e) => {\n            e.target.dispatchEvent(new Event('click'));\n        });\n        el.addEventListener('beforeinput', (e) => {\n            if (e.inputType === 'insertText' && e.data) {\n                this.handleInsertedCharacterToElement(e, e.data);\n            }\n        });\n\n        el.addEventListener('input', (e) => {\n            if (e.inputType === 'deleteContentBackward') {\n                this.handleAndSyncDeletedStringToElement(e.target, e.target.value);\n            }\n        });\n\n        el.addEventListener('keypress', (e) => {\n            e.preventDefault();\n            this.handleInsertedCharacterToElement(e, e.key);\n        });\n\n        el.addEventListener('compositionstart', (evt) => {\n            const selection = evt.target.selectionStart;\n            startSelection = selection;\n        });\n\n        el.addEventListener('compositionend', (evt) => {\n            evt.preventDefault();\n            evt.stopPropagation();\n            const {wordNumber} = this.options;\n            const selection = evt.target.selectionStart;\n            let key = evt.data.normalize('NFKC');\n            let currentSelection = startSelection;\n            evt.target.setSelectionRange(selection, selection);\n            key.split('').forEach(char => {\n                const result = this.handleTypingData(evt, wordNumber, word, currentSelection, char);\n                if (result) {\n                    currentSelection++;\n                }\n            });\n        });\n\n        el.addEventListener('keyup', (event) => {\n            event.preventDefault();\n            const {words, wordNumber} = this.options;\n            const {key, target} = event;\n            let {value} = target;\n            let isValidKey = false;\n            let maxLength = parseInt(target.getAttribute('maxlength'));\n            if ([this.ARROW_LEFT, this.ARROW_RIGHT].includes(key)) {\n                isValidKey = true;\n                const startIndex = target.selectionStart;\n                const gEl = this.options.crosswordEl\n                        .querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${startIndex}']`);\n                if (gEl) {\n                    this.toggleHighlight(word, gEl);\n                }\n            }\n            if (key === this.DELETE || key === this.BACKSPACE) {\n                this.handleAndSyncDeletedStringToElement(target, value);\n            }\n\n            if (key === this.END || key === this.HOME) {\n                isValidKey = true;\n                let startIndex = 0;\n                const word = words.find(o => o.number === parseInt(wordNumber));\n                if (!word) {\n                    return;\n                }\n                if (key === this.END) {\n                    startIndex = word.length - 1;\n                }\n                this.syncFocusCellAndInput(target, startIndex);\n            }\n\n            if (!isValidKey && startSelection >= maxLength) {\n                event.target.value = value.slice(0, maxLength);\n            }\n        });\n\n        el.addEventListener('paste', (event) => {\n            event.preventDefault();\n            const {words, wordNumber} = this.options;\n            const word = words.find(o => o.number === parseInt(wordNumber));\n            let selection = event.target.selectionStart;\n            let value = (event.clipboardData || window.clipboardData).getData('text');\n            value = this.replaceText(value).normalize('NFKC');\n            if (value === \"\") {\n                return;\n            }\n            value.split('').forEach(char => {\n                const result = this.handleTypingData(event, wordNumber, word, selection, char);\n                if (result) {\n                    selection++;\n                }\n            });\n        });\n\n        el.addEventListener('keydown', (e) => {\n            if (e.ctrlKey && e.key.toLowerCase() === this.Z_KEY) {\n                e.preventDefault();\n            }\n            if (e.key === this.ENTER) {\n                e.preventDefault();\n            }\n        });\n\n        el.addEventListener('cut', (event) => {\n            const selectString = document.getSelection().toString();\n            const startIndex = event.target.selectionStart;\n            let {value} = event.target;\n            value = value.substring(0, startIndex) +\n                value.substring(startIndex + selectString.length) +\n                this.makeUnderscore(selectString.length);\n            event.target.value = value;\n            event.clipboardData.setData('text/plain', selectString);\n            event.preventDefault();\n            event.target.setSelectionRange(startIndex, startIndex);\n            // In case the user cuts off the entire answer, we need to update the crossword grid.\n            this.syncLettersByText(value, false);\n        });\n    }\n\n    /**\n     * Handle typing data.\n     *\n     * @param {Object} evt Event data.\n     * @param {Number} wordNumber The word number.\n     * @param {Object} word The word object.\n     * @param {Number} selectionIndex The position of cursor selection.\n     * @param {String} char The character.\n     *\n     * @return {Boolean} True if the data is valid.\n     */\n    handleTypingData(evt, wordNumber, word, selectionIndex, char) {\n        const gelEl = this.options.crosswordEl\n            .querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${selectionIndex}']`);\n        if (this.replaceText(char) === '') {\n            return false;\n        }\n        if (gelEl) {\n            gelEl.querySelector('text.crossword-cell-text').innerHTML = char.toUpperCase();\n            this.bindDataToClueInput(gelEl, char.toUpperCase());\n        }\n        selectionIndex++;\n\n        // Go to next letter.\n        const nexEl = this.options.crosswordEl\n            .querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${selectionIndex}']`);\n        if (nexEl) {\n            this.toggleHighlight(word, nexEl);\n            evt.target.setSelectionRange(selectionIndex, selectionIndex);\n        }\n        return true;\n    }\n\n    /**\n     * Focus cell base on the start index.\n     *\n     * @param {Element} startIndex The start index.\n     * @param {String} word The word data.\n     */\n    focusCellByStartIndex(startIndex, word) {\n        let position = this.calculatePosition(word, startIndex);\n        const rect = this.options.crosswordEl.querySelector(`g rect[x='${position.x}'][y='${position.y}']`);\n        if (rect) {\n            this.options.wordNumber = word.number;\n            this.toggleHighlight(word, rect.closest('g'));\n            this.updateLetterIndexForCells(word);\n        }\n    }\n\n    /**\n     * Focus crossword cell from the start index.\n     *\n     * @param {Element} target The element.\n     * @param {Number} startIndex The start index.\n     */\n    syncFocusCellAndInput(target, startIndex) {\n        const {wordNumber} = this.options;\n        const gEl = this.options.crosswordEl.querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${startIndex}']`);\n        target.setSelectionRange(startIndex, startIndex);\n        if (gEl) {\n            this.toggleFocus(gEl);\n        }\n    }\n\n    /**\n     * Toggle the focus cell.\n     *\n     * @param {Element} gEl The word letter.\n     */\n    toggleFocus(gEl) {\n        const focused = this.options.crosswordEl.querySelector('g rect.crossword-cell-focussed');\n        if (focused) {\n            focused.classList.remove('crossword-cell-focussed');\n            focused.classList.add('crossword-cell-highlighted');\n        }\n        gEl.querySelector('rect').classList.add('crossword-cell-focussed');\n    }\n\n    /**\n     *\n     * Add underscore to deleted string and sync it to crossword clue input.\n     *\n     * @param {Element} target The element target\n     * @param {String} value the string input after we deleted single or multiples character.\n     */\n    handleAndSyncDeletedStringToElement(target, value) {\n        const {words, wordNumber} = this.options;\n        const word = words.find(o => o.number === parseInt(wordNumber));\n        if (!word) {\n            return;\n        }\n        let startIndex = target.selectionStart;\n        const selectionLength = word.length - value.length;\n        const underScore = this.makeUnderscore(selectionLength);\n        // Insert underscore to deleted string.\n        target.value = [value.slice(0, startIndex), underScore, value.slice(startIndex)].join('');\n        // In case the user deletes the entire answer we need to update the crossword grid.\n        this.syncLettersByText(target.value, false);\n        this.syncFocusCellAndInput(target, startIndex);\n    }\n\n    /**\n     * Insert the character to clue input.\n     *\n     * @param {Object} event Event data.\n     * @param {String} value the character we are inserted to the clue input.\n     */\n    handleInsertedCharacterToElement(event, value) {\n        const {words, wordNumber} = this.options;\n        const word = words.find(o => o.number === parseInt(wordNumber));\n        let startIndex = event.target.selectionStart;\n        value = this.replaceText(value).normalize('NFKC');\n        if (value === '') {\n            return;\n        }\n        this.handleTypingData(event, wordNumber, word, startIndex, value);\n    }\n}\n"],"names":["CrosswordClue","CrosswordQuestion","constructor","options","setUpClue","words","readonly","this","crosswordEl","closest","querySelectorAll","forEach","el","questionId","dataset","questionid","word","find","o","number","parseInt","inputEl","querySelector","value","makeUnderscore","length","disabled","addEventForClueInput","startSelection","addEventListener","e","startIndex","target","selectionStart","focusCellByStartIndex","focusClue","setStickyClue","dispatchEvent","Event","inputType","data","handleInsertedCharacterToElement","handleAndSyncDeletedStringToElement","preventDefault","key","evt","selection","stopPropagation","wordNumber","normalize","currentSelection","setSelectionRange","split","char","handleTypingData","event","isValidKey","maxLength","getAttribute","ARROW_LEFT","ARROW_RIGHT","includes","gEl","toggleHighlight","DELETE","BACKSPACE","END","HOME","syncFocusCellAndInput","slice","clipboardData","window","getData","replaceText","ctrlKey","toLowerCase","Z_KEY","ENTER","selectString","document","getSelection","toString","substring","setData","syncLettersByText","selectionIndex","gelEl","innerHTML","toUpperCase","bindDataToClueInput","nexEl","position","calculatePosition","rect","x","y","updateLetterIndexForCells","toggleFocus","focused","classList","remove","add","selectionLength","underScore","join"],"mappings":"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"}